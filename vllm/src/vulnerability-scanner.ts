import { execSync } from "child_process";
import { existsSync } from "fs";
import { join } from "path";

export interface VulnerabilityReport {
    hasVulnerabilities: boolean;
    summary: VulnerabilitySummary;
    vulnerabilities: Vulnerability[];
    outdatedDependencies: OutdatedDependency[];
}

export interface VulnerabilitySummary {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    info: number;
    total: number;
}

export interface Vulnerability {
    name: string;
    severity: "critical" | "high" | "moderate" | "low" | "info";
    title: string;
    description: string;
    version: string;
    fixAvailable: boolean;
    recommendedVersion?: string;
    cves: string[];
    url?: string;
}

export interface OutdatedDependency {
    name: string;
    current: string;
    wanted: string;
    latest: string;
    type: "dependencies" | "devDependencies";
}

export class VulnerabilityScanner {
    private rootPath: string;

    constructor(rootPath: string) {
        this.rootPath = rootPath;
    }

    async scan(): Promise<VulnerabilityReport> {
        const packageJsonPath = join(this.rootPath, "package.json");

        if (!existsSync(packageJsonPath)) {
            return this.emptyReport();
        }

        const [auditResults, outdatedResults] = await Promise.all([
            this.runNpmAudit(),
            this.checkOutdated(),
        ]);

        auditResults.outdatedDependencies = outdatedResults;

        return auditResults;
    }

    private async runNpmAudit(): Promise<VulnerabilityReport> {
        try {
            // npm audit returns non-zero exit code if vulnerabilities found
            const output = execSync("npm audit --json", {
                cwd: this.rootPath,
                encoding: "utf-8",
                stdio: ["pipe", "pipe", "pipe"],
            });

            return this.parseAuditOutput(output);
        } catch (error: any) {
            // npm audit exits with error code when vulnerabilities are found
            if (error.stdout) {
                return this.parseAuditOutput(error.stdout);
            }

            // Actual error (not just vulnerabilities)
            console.error("Error running npm audit:", error.message);
            return this.emptyReport();
        }
    }

    private parseAuditOutput(output: string): VulnerabilityReport {
        try {
            const data = JSON.parse(output);

            // Handle npm audit v7+ format
            if (data.vulnerabilities) {
                return this.parseAuditV7(data);
            }

            // Handle npm audit v6 format
            if (data.advisories) {
                return this.parseAuditV6(data);
            }

            return this.emptyReport();
        } catch (error) {
            console.error("Error parsing npm audit output:", error);
            return this.emptyReport();
        }
    }

    private parseAuditV7(data: any): VulnerabilityReport {
        const vulnerabilities: Vulnerability[] = [];
        const summary: VulnerabilitySummary = {
            critical: 0,
            high: 0,
            moderate: 0,
            low: 0,
            info: 0,
            total: 0,
        };

        for (const [name, vuln] of Object.entries(data.vulnerabilities || {})) {
            const vulnData = vuln as any;
            const severity = vulnData.severity as Vulnerability["severity"];

            summary[severity]++;
            summary.total++;

            vulnerabilities.push({
                name,
                severity,
                title: vulnData.via?.[0]?.title || "Unknown vulnerability",
                description: vulnData.via?.[0]?.description || "",
                version: vulnData.range || "unknown",
                fixAvailable: vulnData.fixAvailable !== false,
                recommendedVersion: vulnData.fixAvailable?.version,
                cves: this.extractCVEs(vulnData),
                url: vulnData.via?.[0]?.url,
            });
        }

        return {
            hasVulnerabilities: summary.total > 0,
            summary,
            vulnerabilities: vulnerabilities.sort((a, b) =>
                this.severityWeight(b.severity) - this.severityWeight(a.severity)
            ),
            outdatedDependencies: [],
        };
    }

    private parseAuditV6(data: any): VulnerabilityReport {
        const vulnerabilities: Vulnerability[] = [];
        const summary: VulnerabilitySummary = {
            critical: 0,
            high: 0,
            moderate: 0,
            low: 0,
            info: 0,
            total: 0,
        };

        for (const [id, advisory] of Object.entries(data.advisories || {})) {
            const adv = advisory as any;
            const severity = adv.severity as Vulnerability["severity"];

            summary[severity]++;
            summary.total++;

            vulnerabilities.push({
                name: adv.module_name,
                severity,
                title: adv.title,
                description: adv.overview || "",
                version: adv.vulnerable_versions || "unknown",
                fixAvailable: !!adv.patched_versions,
                recommendedVersion: adv.patched_versions,
                cves: adv.cves || [],
                url: adv.url,
            });
        }

        return {
            hasVulnerabilities: summary.total > 0,
            summary,
            vulnerabilities: vulnerabilities.sort((a, b) =>
                this.severityWeight(b.severity) - this.severityWeight(a.severity)
            ),
            outdatedDependencies: [],
        };
    }

    private extractCVEs(vulnData: any): string[] {
        const cves: string[] = [];

        if (vulnData.via) {
            for (const via of vulnData.via) {
                if (typeof via === "object" && via.source) {
                    const cveMatch = via.source.toString().match(/CVE-\d{4}-\d+/g);
                    if (cveMatch) {
                        cves.push(...cveMatch);
                    }
                }
            }
        }

        return [...new Set(cves)]; // Remove duplicates
    }

    private async checkOutdated(): Promise<OutdatedDependency[]> {
        try {
            const output = execSync("npm outdated --json", {
                cwd: this.rootPath,
                encoding: "utf-8",
                stdio: ["pipe", "pipe", "pipe"],
            });

            return this.parseOutdatedOutput(output);
        } catch (error: any) {
            // npm outdated exits with code 1 when outdated packages exist
            if (error.stdout) {
                return this.parseOutdatedOutput(error.stdout);
            }
            return [];
        }
    }

    private parseOutdatedOutput(output: string): OutdatedDependency[] {
        try {
            const data = JSON.parse(output);
            const outdated: OutdatedDependency[] = [];

            for (const [name, info] of Object.entries(data)) {
                const pkg = info as any;
                outdated.push({
                    name,
                    current: pkg.current,
                    wanted: pkg.wanted,
                    latest: pkg.latest,
                    type: pkg.type || "dependencies",
                });
            }

            return outdated;
        } catch {
            return [];
        }
    }

    private severityWeight(severity: Vulnerability["severity"]): number {
        const weights = {
            critical: 5,
            high: 4,
            moderate: 3,
            low: 2,
            info: 1,
        };
        return weights[severity] || 0;
    }

    private emptyReport(): VulnerabilityReport {
        return {
            hasVulnerabilities: false,
            summary: {
                critical: 0,
                high: 0,
                moderate: 0,
                low: 0,
                info: 0,
                total: 0,
            },
            vulnerabilities: [],
            outdatedDependencies: [],
        };
    }
}
