import { jest, describe, beforeEach, afterEach, it, expect } from '@jest/globals';

jest.unstable_mockModule('child_process', () => ({
    execSync: jest.fn(),
}));

jest.unstable_mockModule('fs', () => ({
    existsSync: jest.fn(),
}));

import type { VulnerabilityScanner as VulnerabilityScannerType } from "../../src/vulnerability-scanner.js";
const { VulnerabilityScanner } = await import("../../src/vulnerability-scanner.js");
const fs = await import("fs");
const cp = await import("child_process");

describe("VulnerabilityScanner", () => {
    let scanner: VulnerabilityScannerType;
    const mockRootPath = "/test/repo";

    const mockedExistsSync = fs.existsSync as unknown as jest.Mock<any>;
    const mockedExecSync = cp.execSync as unknown as jest.Mock<any>;

    beforeEach(() => {
        scanner = new VulnerabilityScanner(mockRootPath);
        jest.clearAllMocks();
        jest.spyOn(console, 'error').mockImplementation(() => { });
    });

    afterEach(() => {
        jest.restoreAllMocks();
    });

    it("should return empty report if package.json does not exist", async () => {
        mockedExistsSync.mockReturnValue(false);

        const report = await scanner.scan();

        expect(report.hasVulnerabilities).toBe(false);
        expect(report.summary.total).toBe(0);
    });

    it("should parse npm audit v7 output", async () => {
        mockedExistsSync.mockReturnValue(true);

        const mockAuditOutput = JSON.stringify({
            vulnerabilities: {
                "vuln-package": {
                    severity: "high",
                    range: "1.0.0",
                    fixAvailable: { version: "1.0.1" },
                    via: [{ title: "Vuln Title", description: "Desc", url: "http://example.com", source: "CVE-2023-1234" }]
                }
            }
        });

        const mockOutdatedOutput = "{}";

        // Mock execSync to return appropriate output based on command
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return mockAuditOutput;
            if (cmd.includes("npm outdated")) return mockOutdatedOutput;
            return "";
        });

        const report = await scanner.scan();

        expect(report.hasVulnerabilities).toBe(true);
        expect(report.summary.high).toBe(1);
        expect(report.vulnerabilities).toHaveLength(1);
        expect(report.vulnerabilities[0].name).toBe("vuln-package");
        expect(report.vulnerabilities[0].cves).toContain("CVE-2023-1234");
    });

    it("should handle npm audit error exit code", async () => {
        mockedExistsSync.mockReturnValue(true);

        const mockAuditOutput = JSON.stringify({
            vulnerabilities: {
                "vuln-package": {
                    severity: "critical",
                    via: [{ source: "CVE-2023-4321" }]
                }
            }
        });

        // npm audit throws when vulns are found
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) {
                const error: any = new Error("Command failed");
                error.stdout = mockAuditOutput;
                throw error;
            }
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();

        expect(report.hasVulnerabilities).toBe(true);
        expect(report.summary.critical).toBe(1);
    });

    it("should parse outdated dependencies", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return "{}";
            if (cmd.includes("npm outdated")) {
                return JSON.stringify({
                    "old-package": {
                        current: "1.0.0",
                        wanted: "1.1.0",
                        latest: "2.0.0",
                        type: "dependencies"
                    }
                });
            }
            return "";
        });

        const report = await scanner.scan();

        expect(report.outdatedDependencies).toHaveLength(1);
        expect(report.outdatedDependencies[0].name).toBe("old-package");
        expect(report.outdatedDependencies[0].latest).toBe("2.0.0");
    });
    it("should parse npm audit v6 output", async () => {
        mockedExistsSync.mockReturnValue(true);

        const mockAuditOutput = JSON.stringify({
            advisories: {
                "123": {
                    module_name: "vuln-module",
                    severity: "moderate",
                    title: "Moderate Vuln",
                    overview: "Overview",
                    vulnerable_versions: "<1.2.0",
                    patched_versions: ">=1.2.0",
                    cves: ["CVE-2023-5678"],
                    url: "http://example.com/123"
                }
            }
        });

        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return mockAuditOutput;
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();

        expect(report.hasVulnerabilities).toBe(true);
        expect(report.summary.moderate).toBe(1);
        expect(report.vulnerabilities[0].name).toBe("vuln-module");
    });

    it("should handle invalid JSON in npm audit output", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return "invalid json";
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();
        expect(report.hasVulnerabilities).toBe(false);
    });

    it("should handle error in npm outdated", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return "{}";
            if (cmd.includes("npm outdated")) {
                const error: any = new Error("Outdated failed");
                error.stdout = "invalid json";
                throw error;
            }
            return "";
        });

        const report = await scanner.scan();
        expect(report.outdatedDependencies).toHaveLength(0);
    });

    it("should handle npm outdated returning results in error stdout", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return "{}";
            if (cmd.includes("npm outdated")) {
                const error: any = new Error("Outdated failed");
                error.stdout = JSON.stringify({
                    "pkg": { current: "1", wanted: "2", latest: "3" }
                });
                throw error;
            }
            return "";
        });

        const report = await scanner.scan();
        expect(report.outdatedDependencies).toHaveLength(1);
    });

    it("should handle missing via in npm audit v7", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) {
                return JSON.stringify({
                    vulnerabilities: {
                        "p": { severity: "low" }
                    }
                });
            }
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();
        expect(report.vulnerabilities[0].title).toBe("Unknown vulnerability");
    });

    it("should extract multiple CVEs correctly", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) {
                return JSON.stringify({
                    vulnerabilities: {
                        "p": {
                            severity: "low",
                            via: [{ source: "Check CVE-2021-0001 and CVE-2021-0002" }]
                        }
                    }
                });
            }
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();
        expect(report.vulnerabilities[0].cves).toEqual(["CVE-2021-0001", "CVE-2021-0002"]);
    });

    it("should sort vulnerabilities by severity", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) {
                return JSON.stringify({
                    vulnerabilities: {
                        "low-v": { severity: "low" },
                        "critical-v": { severity: "critical" },
                        "high-v": { severity: "high" }
                    }
                });
            }
            if (cmd.includes("npm outdated")) return "{}";
            return "";
        });

        const report = await scanner.scan();
        expect(report.vulnerabilities[0].severity).toBe("critical");
        expect(report.vulnerabilities[1].severity).toBe("high");
        expect(report.vulnerabilities[2].severity).toBe("low");
    });

    it("should handle fatal error in checkOutdated (no stdout)", async () => {
        mockedExistsSync.mockReturnValue(true);
        mockedExecSync.mockImplementation((cmd: string) => {
            if (cmd.includes("npm audit")) return "{}";
            if (cmd.includes("npm outdated")) {
                throw new Error("Fatal failure");
            }
            return "";
        });

        const report = await scanner.scan();
        expect(report.outdatedDependencies).toHaveLength(0);
    });
});

